# 回溯算法

动态规划一般是求解最值，动态规划的特点的有：
1. 求最值
2. 满足最优子问题
3. 具有重叠子结构，可以通过备忘录（缓存）实现对子结构的优化

回溯算法也是一种暴力求解的方法，穷举的过程就是遍历一个多叉树的过程
穷举的过程类似于DFS，回溯算法和 DFS 算法的细微差别是：回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」

多叉树的遍历模版
```
void traverse(TreeNode root) {
    for (TreeNode child : root.childern) {
        // 前序位置需要的操作
        traverse(child);
        // 后序位置需要的操作
    }
}
```

解决一个回溯问题，实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，你只需要思考 3 个问题：
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择。
3、结束条件：也就是到达决策树底层，无法再做选择的条件。

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

## 全排列
全排列的过程就是一种遍历多叉树的过程
维护 track
