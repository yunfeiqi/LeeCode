## 排序算法

### 选择排序: 挑选排序
给定一个数组，从数据中选择一个最小值，并把该值放到数组最开始位置，之后在从数据中选择一个次小值，并把该指放到数组第二位置以此类推。
O(N2)

**选择排序：从数组中选择最小值放到最开始位置**

### 冒泡排序：排队排序
给定一个数组，依次比较相邻的邻居，将最大值保持在最右边，当把N范围内最大值确定后，在确定N-1位置上的值。
O(N2)
**比较相邻邻居，将最大的值保持在右边**

### 异或运算
1. 异或运算也可以视为无进位相加
2. 异或运算满足交换律和结合律
3. 相同为0，不同为1
4. 0 ^ N = N 
5. N ^ N = 0
 
异或完成交换：a和b在内存中是独立内存
```aidl
a = a ^ b ;  
b = a ^ b ; // b = a ^ b ^ b = a 
a = a ^ b ; // a = a ^b ^ a = b
```
1) 给定一个数组，已知只有一种数字出现了奇数次，其他出现偶数次，找到它
2) 给定一个数组，已知只有两种数字出现了奇数次，其他出现偶数次，找到它们（提示：将最终的异或结果按位置拆开）

### 插入排序：插扑克
给定数组，依次检查从 0-N 范围内有序，每次拿到数后，和前面有序的序列比较，检查是否满足了 0-N' 范围内有序
好像是打扑克时，拿到一个新的牌后，把新牌插入到手中有序的牌中。
O(N2)


*每次迭代的中间结果都被丢弃，只保留了最终的结果*

### 快速排序
额外空间复杂度：LogN

### 热身1
给定一个数组，和一个数num，请把小于num的数放到数组的左边，大于num的数放到数组右边，要求空间复杂度为O(1)，时间复杂度为O(N)


### 热身2
给定一个数组，和一个数num，请把小于num的数放到数组的左边，等于放中间，大于num的数放到数组右边，要求空间复杂度为O(1)，时间复杂度为O(N)
i < num  -> left +1 ,i next
i == num -> i next
i > num  -> right -1 , i 不变（因为i 是新换来的数字）

### 快排01 
N2
1. 指定最后一个数字为num,在[0,N-1] 范围内实现左边部分小于等于num，右边部分大于num
2. 交换num和大于区域的第一个数交换（小于等于区域被扩充，右边都是大于num，num的位置被确定）
3. 将左边区域和右边区域重复1，2步骤


### 快排02
N2
1. 指定最后一个数字为num,在[0,N-1] 范围内，完成荷兰国旗问题
2. 交换num和大于区域的第一个数交换
3. 将小于num部分和大于num部分重复1，2步骤 

### 快排03
N2原因：指定的划分位置的值太偏
划分位置的值在几乎中点的位置最好

1. 每次选择num的策略是：随机选择一个数和最后一个位置交换
2. 之后再实现快排

因为随机选择一个数字，最好情况和最坏情况的概率比是0.5









 






