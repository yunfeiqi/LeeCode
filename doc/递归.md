## 递归
用系统栈把计算过程压栈，递归过程就是一个二叉树，完成一个后序遍历

### 题目1:求数组的最大值  

### 时间复杂度
递归的时间复杂度：
Master 公式条件：子问题的规模是固定的
```
           规模等量      其他计算
T(N) = a * T(N/b) + o(N^d)
母问题      子问题

log_b(a) < d  ==> O(N^d)
log_b(a) > d  ==> O(N^(log_b(a)))
log_b(a) = d  ==> O(N^d * logN)
```
题目1的时间复杂度为：
```aidl
T(N) =  2 * T(N/2)  + O(1)
```

### 归并排序：（外排序）
将数组拆分成两部分，先使左侧部分排好序，之后使右侧部分排好序，最后将两部分融合（拷贝两部分内容），需要开辟额外的空间
1. 左边有序
2. 右边有序
3. 合并左边和右边

O(N*LogN)

*每次比较之后的中间结果没有被直接丢弃，而是通过额外空间利用中间结果完成了局部有序，所以提高了比较结果的利用率*

### 小和问题
小和：数组中某个位置，左边比当前值小的数字之和称为小和
数组的小和：数组每个位置所有小和的和为数组的小和

提示：将问题转换为，数组中任意位置，右边有几个数字比当前数字大，就当前位置数值而言就会有几个小和
Merge 的过程可以产生附加物，该过程可以计算小和。

关键： 
1. 小范围是有序
2. 合并过程时小标不会遗漏和重复的比较
3. 在Merge时和经典的Merge过程不同之处在于，Merge时左边严格小于右边时拷贝左边，否则需要先copy右边值（必须）


*不会漏算也不会重算的原因：组内不会产生小和，只有跨组才会产生小和*

### 求逆序对
数组中，左边的数如果比右边的数大，则两个数构成一个逆序对，请打印所有逆序对。


















