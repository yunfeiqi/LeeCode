## 堆

### 堆结构
堆是一个完全二叉树结构
大根堆：完全二叉树中，每一个子树的二叉树最大值就是头节点值
小根堆：完全二叉树中，每一个子树的二叉树最小值就是头节点值

将一个从0开始的数组连续区域内：
i 位置的左孩子： 2*i + 1
i 位置的右孩子： 2*i + 2
i 位置的父： (i-1)/2


LogN
HeapInsert：向上比较（当前值和父亲比较，如果比父亲大则与之交换）
1. 准备一个空数组
2. 当收到一个数字后，和父节点((i-1)/2)比较，如果当前值比父节点大则交换；
3. 重复第二步


Heapify： 向下比较
查找给过所有值的最大值，并删除该最大值，调整大根堆
1. 记录根节点
2. 将最后一个位置值复制到根节点
3. 在同层选择出最大值
4. 同层最大值和父节点比较，如果父节点失败，则父节点和最大值交换
5. 重复3、4步骤
6. 直到没有孩子或者子孩子没有大于该父节点时停止

 ### 深入
Heapsize 范围内，替换其中任一一个位置值，还保持堆结构
LogN 

### 堆排序
时间复杂度：N*LogN
空间复杂度：O(1)

给定一个数组
1. 首先让数组变成一个大根堆，heapsize 从0 逐步扩展成 size
2. 把最大值和堆上最后一个位置交换
3. heapsize -- ，把最后位置和堆断开，此时已经完成了 0-N 范围内完成了最大值
4. 在0-(N-1)范围内做Heapify，继续调整为大根堆
5. 交换0和 N-1 位置数值
6. heapsize --
7. 重复以上步骤，直到heapsize=1


### 调整一个满二叉树，调增为大根堆
时间复杂度：O(N)

### 堆排序扩展
已知一个几乎有序的数组，如果把数组排好序，每个元素移动的距离可以不超过k,k相对小，选择合适的排序方法排序
利用小根堆，把最小值赋值到数组中对应的位置
O(N*logK)

PriorityQueue：小根堆





















